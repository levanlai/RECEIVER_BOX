/*
 *        DDDDDD          RRRRRR         EEEEEE         AAA            MM     M
 *       D     D         R     R        E             A    A          M M  M  M
 *      D     D         RRRRRR         EEEEEE        AAAAAAA         M   M   M
 *     D     D         R   R          E             A     A         M       M
 *    DDDDDD          R     R        EEEEEE        A     A         M       M
 *
 *  Digital         Research  in  Electronics    Acoustics        &     Music
 *_____________________________________________________________________________
 *
 * SAM5000 based product
 * COPYRIGHT (c) DREAM S.A.S. 2022
 *
 * C main entry point, initializations, base loop
 * This file can be modified by user and will not be overwritten by Dream DSP Designer.
 *_____________________________________________________________________________
*/

//#define _USE_SERIAL_MIDI 1	// uncomment this line to use MIDI over UART instead USB
//#define _BOARD_MIDIBAUDRATE 115200	// baud rate used for serial MIDI/UART (default is 31250)
#define _USE_GLOBAL_PRESET 0 // 1=include global preset handling, 0=not using global preset

#include <system.h>
#include <DreamBoards.h>
#ifdef _USE_SERIAL_MIDI
#include <libmidi.h>
#else
#include <libusb.h>
#endif
#include "dspDesigner.h"
#include "midictrl.h"
#if _USE_GLOBAL_PRESET
#include "GlobalPresets.h"
#endif

#include "fbcHandler.h"

#ifndef _USE_SERIAL_MIDI
// use MIDI over USB for parameter control
extern const unsigned short UsbDescriptorInfo[]; //from USB descripter file (generated by UsbDescUI)

// C-preprocessor two-level expansion to build constant
#define _SAM5XXX_PORTNAME(port,val)	SAM5XXX_USB ## port ## _ ## val
#define SAM5XXX_PORTNAME(port,val)	_SAM5XXX_PORTNAME(port, val)
#define	SAM5XXX_USB_PORT	0	//0 or 1 (must be set to 0 on SAM5504/5704)
#define SAM5XXX_USB(val)	SAM5XXX_PORTNAME(SAM5XXX_USB_PORT, val)

#define _SUPPORT_USB_AUDIO	0	//set 1 in case of using USB Descriptor with Audio function
#if _SUPPORT_USB_AUDIO
extern const unsigned short UsbDescriptorInfo[]; //from added USB descriptor .c or .s file
WORD usb_dsp;	//DSP ID for USB Audio
#else
WORD UsbMidiInBuf[64], UsbMidiOutBuf[348];	// USB-MIDI queue buffers

// USB Descriptor created with UsbDescUI.exe using Descriptor Export "C-Array" 
// Generated from DDDUsbDescriptor.ucf file (1 MIDI IN & 1 MIDI OUT port, no Audio)
const unsigned short UsbDescriptorInfo[140] = {
	0x0112, 0x0008, 0x0082, 0x0000, 0x0000, 0x0002, 0x0000, 0x0000,	/*     0 */
	0x0004, 0x000D, 0x0011, 0x001E, 0x0031, 0x0308, 0x006E, 0x002F,	/*     8 */
	0x0061, 0x031A, 0x0044, 0x0052, 0x0045, 0x0041, 0x004D, 0x0020,	/*    16 */
	0x0053, 0x002E, 0x0041, 0x002E, 0x0053, 0x002E, 0x0326, 0x0053,	/*    24 */
	0x0041, 0x004D, 0x0035, 0x0030, 0x0030, 0x0030, 0x0020, 0x0045,	/*    32 */
	0x0076, 0x0061, 0x006C, 0x0020, 0x0042, 0x006F, 0x0061, 0x0072,	/*    40 */
	0x0064, 0x0322, 0x0046, 0x0075, 0x006C, 0x006C, 0x0053, 0x0070,	/*    48 */
	0x0065, 0x0065, 0x0064, 0x0020, 0x0043, 0x006F, 0x006E, 0x0066,	/*    56 */
	0x0069, 0x0067, 0x0012, 0x0112, 0x0101, 0x0000, 0x4000, 0x2485,	/*    64 */
	0x433D, 0x0100, 0x0302, 0x0100, 0x0065, 0x0209, 0x0065, 0x0102,	/*    72 */
	0x8004, 0x0932, 0x0004, 0x0000, 0x0101, 0x0000, 0x2409, 0x0001,	/*    80 */
	0x0901, 0x0100, 0x0901, 0x0104, 0x0200, 0x0301, 0x0300, 0x2407,	/*    88 */
	0x0001, 0x4101, 0x0600, 0x0224, 0x0101, 0x0603, 0x0224, 0x0202,	/*    96 */
	0x0903, 0x0324, 0x0301, 0x0201, 0x0301, 0x2409, 0x0203, 0x0104,	/*   104 */
	0x0101, 0x0903, 0x0305, 0x4002, 0x0000, 0x0000, 0x2505, 0x0101,	/*   112 */
	0x0901, 0x8305, 0x4002, 0x0000, 0x0000, 0x2505, 0x0101, 0x0003,	/*   120 */
	0x0502, 0x0006, 0x0042, 0x0000, 0x004C, 0x0000, 0x0000, 0x0000,	/*   128 */
	0x0000, 0x0000, 0x0000, 0x0080
	};
#endif

//-------------------------------------------------------------------------
void InitUSB( void )
{
	if( UsbDescriptorInfo[3] != 0 )	//is it a USB descriptor for high speed?
		_USBDDE_SAM5xxx_IOCTL(SAM5XXX_USB_PORT, USB5XXXIOCTL_CONFIGURE, USB5XXX_CONFIGURE_DEVICE|USB5XXX_CONFIGURE_HIGH_SPEED);
	else
		_USBDDE_SAM5xxx_IOCTL(SAM5XXX_USB_PORT, USB5XXXIOCTL_CONFIGURE, USB5XXX_CONFIGURE_DEVICE|USB5XXX_CONFIGURE_FULL_SPEED);
	_USBDDE_SAM5xxx_IOCTL(SAM5XXX_USB_PORT, USB5XXXIOCTL_ACTIVATE, 0);
	_USB_Initialize();
#if _SUPPORT_USB_AUDIO
// initializations for USB Audio+MIDI functions:
	usb_dsp = _DSPalloc(1);	//allocate one DSP for USB Audio function
	_USB_InitRegisterEntry(_USB_PTR(_USBDDE_SAM5xxxAC), usb_dsp);
	_USB_InitStartupEx(_USB_DESC(UsbDescriptorInfo), SAM5XXX_USB(ADDR), 0, SAM5XXX_USB(P24INTBIT));
	_DSProutIN(usb_dsp, DAAD0L,DAAD0R,IBUSEIN,IBUSEIN);	//audio routing for USB to Host (recording)
	_DSProut(usb_dsp, DABD0L,DABD0R,IBUSFOUT,IBUSFOUT);		//audio routing for USB from Host (playback)
#else
// initializations for USB MIDI only functions:
	_USB_InitRegisterEntry(_USB_PTR(_USBDDE_SAM5xxx), 0);
	_USB_InitRegisterEntry(_USB_PTR(_USBDDE_MidiClass), 0);
	_USB_InitStartupEx(_USB_DESC(UsbDescriptorInfo), SAM5XXX_USB(ADDR), SAM5XXX_USB(INTPORT), SAM5XXX_USB(INTBIT) );	// for SAM5XXX on-chip USB device
	_USBMC_InitSetBuffer(UsbMidiInBuf, sizeof(UsbMidiInBuf), UsbMidiOutBuf, sizeof(UsbMidiOutBuf));
#endif
	_USBDDE_SAM5xxx_IOCTL(SAM5XXX_USB_PORT, USB5XXXIOCTL_ACTIVATE, 1);	//enable USB (should be done short before base level loop entry)
}
#endif

void main (void)
{
	DWORD midi_event;
	WORD activity_counter;

	_BOARD_ACTIVITY_LED_INIT();
	_BOARD_ACTIVITY_LED_ON();	//set "ACTIVITY" LED ON by default
	_BOARD_AUDIO_CONFIG();
	_BOARD_CODEC_INIT();

	_DSPresetAll();
	dspDesigner_InitAndRoute();
	dspDesigner_InitNrpnFunction();

#if _USE_GLOBAL_PRESET
	dspDesigner_LoadGlobalPreset( _cptr32( globalpreset[0] ) );
#endif


#ifdef _USE_SERIAL_MIDI
	// initialize serial MIDI for control...
	_MIDI_InitEx( _BOARD_MIDIBAUDRATE );	//initializing also Timer 2 for serial baud rate
	_MIDI_InitEvent();
#else
	InitUSB();
	_wrio( TIMER2PORT, _Sys_CalcTimerReload(_BOARD_MIDIBAUDRATE));	//init Timer 2 reload value
	_orio( CONTROLPORT, ENA_TIMER2 );	//enable Timer 2
#endif
	_wrio( TIMER0PORT, _BOARD_TIMER0V );	//Timer 0 reload value for ~10ms (base level timer)
	_orio( CONTROLPORT, ENA_TIMER0 );	//enable Timer 0

	FBCStatus_Init();

	while (1) 
	{

		FBC_BaseLevels();
#ifdef _USE_SERIAL_MIDI
		_MIDI_Flush();
		if(_MIDI_ReceiveEvent(&midi_event))	//MIDI message received on serial MIDI?
#else
		_USB_Poll();
		if(_USBMC_PollMidiEvent(&midi_event))	//MIDI message received on USB MIDI?
#endif
		{
			dspDesigner_HandleMidiEvent( midi_event );
			if( !activity_counter )activity_counter=20;
		}

		if( _rdtr0())	// Timer 0 request?
		{
			//do task at 10ms rate here...
			
			if( activity_counter>0 )	//ACTIVITY LED blinking...
			{
				if( --activity_counter>10 ) _BOARD_ACTIVITY_LED_OFF();
				else _BOARD_ACTIVITY_LED_ON();
			}
		}
	}
}

void Send( UCHAR data )
{
#ifdef _USE_SERIAL_MIDI
	_MIDI_Send( data );
#else
	_USBMC_Send( data );
#endif
}
