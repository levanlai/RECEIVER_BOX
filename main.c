 #include <system.h>
#include <trace.h>
#include <sys5000.h>
#include "sys/sys_io.h"
#include <libusb.h>
#include "config.h"
#include "dsp/dspDesigner.h"
#include "dsp/midictrl.h"
#include "lcd/uart.h"
#include "user_adc.h"
#if _USE_GLOBAL_PRESET
#include "dsp/GlobalPresets.h"
#endif
#include "libFX5000.h"
#include "utils.h"

WORD powerState=Turn_OFF;
#if ENABLE_USB
extern const unsigned short UsbDescriptorInfo[]; //from USB descripter file (generated by UsbDescUI)

// C-preprocessor two-level expansion to build constant
#define _SAM5XXX_PORTNAME(port,val)	SAM5XXX_USB ## port ## _ ## val
#define SAM5XXX_PORTNAME(port,val)	_SAM5XXX_PORTNAME(port, val)
#define	SAM5XXX_USB_PORT	0	//0 or 1 (must be set to 0 on SAM5504/5704)
#define SAM5XXX_USB(val)	SAM5XXX_PORTNAME(SAM5XXX_USB_PORT, val)

WORD UsbMidiInBuf[64], UsbMidiOutBuf[348];	// USB-MIDI queue buffers

// USB Descriptor created with UsbDescUI.exe using Descriptor Export "C-Array" 
// Generated from DDDUsbDescriptor.ucf file (1 MIDI IN & 1 MIDI OUT port, no Audio)
const unsigned short UsbDescriptorInfo[140] = {
	0x0112, 0x0008, 0x0082, 0x0000, 0x0000, 0x0002, 0x0000, 0x0000,	/*     0 */
	0x0004, 0x000D, 0x0011, 0x001E, 0x0031, 0x0308, 0x006E, 0x002F,	/*     8 */
	0x0061, 0x031A, 0x0044, 0x0052, 0x0045, 0x0041, 0x004D, 0x0020,	/*    16 */
	0x0053, 0x002E, 0x0041, 0x002E, 0x0053, 0x002E, 0x0326, 0x0053,	/*    24 */
	0x0041, 0x004D, 0x0035, 0x0030, 0x0030, 0x0030, 0x0020, 0x0045,	/*    32 */
	0x0076, 0x0061, 0x006C, 0x0020, 0x0042, 0x006F, 0x0061, 0x0072,	/*    40 */
	0x0064, 0x0322, 0x0046, 0x0075, 0x006C, 0x006C, 0x0053, 0x0070,	/*    48 */
	0x0065, 0x0065, 0x0064, 0x0020, 0x0043, 0x006F, 0x006E, 0x0066,	/*    56 */
	0x0069, 0x0067, 0x0012, 0x0112, 0x0101, 0x0000, 0x4000, 0x2485,	/*    64 */
	0x433D, 0x0100, 0x0302, 0x0100, 0x0065, 0x0209, 0x0065, 0x0102,	/*    72 */
	0x8004, 0x0932, 0x0004, 0x0000, 0x0101, 0x0000, 0x2409, 0x0001,	/*    80 */
	0x0901, 0x0100, 0x0901, 0x0104, 0x0200, 0x0301, 0x0300, 0x2407,	/*    88 */
	0x0001, 0x4101, 0x0600, 0x0224, 0x0101, 0x0603, 0x0224, 0x0202,	/*    96 */
	0x0903, 0x0324, 0x0301, 0x0201, 0x0301, 0x2409, 0x0203, 0x0104,	/*   104 */
	0x0101, 0x0903, 0x0305, 0x4002, 0x0000, 0x0000, 0x2505, 0x0101,	/*   112 */
	0x0901, 0x8305, 0x4002, 0x0000, 0x0000, 0x2505, 0x0101, 0x0003,	/*   120 */
	0x0502, 0x0006, 0x0042, 0x0000, 0x004C, 0x0000, 0x0000, 0x0000,	/*   128 */
	0x0000, 0x0000, 0x0000, 0x0080
	};

//-------------------------------------------------------------------------
void InitUSB( void )
{
	if( UsbDescriptorInfo[3] != 0 )	//is it a USB descriptor for high speed?
		_USBDDE_SAM5xxx_IOCTL(SAM5XXX_USB_PORT, USB5XXXIOCTL_CONFIGURE, USB5XXX_CONFIGURE_DEVICE|USB5XXX_CONFIGURE_HIGH_SPEED);
	else
		_USBDDE_SAM5xxx_IOCTL(SAM5XXX_USB_PORT, USB5XXXIOCTL_CONFIGURE, USB5XXX_CONFIGURE_DEVICE|USB5XXX_CONFIGURE_FULL_SPEED);
	_USBDDE_SAM5xxx_IOCTL(SAM5XXX_USB_PORT, USB5XXXIOCTL_ACTIVATE, 0);
	_USB_Initialize();
#if _SUPPORT_USB_AUDIO
// initializations for USB Audio+MIDI functions:
	usb_dsp = _DSPalloc(1);	//allocate one DSP for USB Audio function
	_USB_InitRegisterEntry(_USB_PTR(_USBDDE_SAM5xxxAC), usb_dsp);
	_USB_InitStartupEx(_USB_DESC(UsbDescriptorInfo), SAM5XXX_USB(ADDR), 0, SAM5XXX_USB(P24INTBIT));
	_DSProutIN(usb_dsp, DAAD0L,DAAD0R,IBUSEIN,IBUSEIN);	//audio routing for USB to Host (recording)
	_DSProut(usb_dsp, DABD0L,DABD0R,IBUSFOUT,IBUSFOUT);		//audio routing for USB from Host (playback)
#else
// initializations for USB MIDI only functions:
	_USB_InitRegisterEntry(_USB_PTR(_USBDDE_SAM5xxx), 0);
	_USB_InitRegisterEntry(_USB_PTR(_USBDDE_MidiClass), 0);
	_USB_InitStartupEx(_USB_DESC(UsbDescriptorInfo), SAM5XXX_USB(ADDR), SAM5XXX_USB(INTPORT), SAM5XXX_USB(INTBIT) );	// for SAM5XXX on-chip USB device
	_USBMC_InitSetBuffer(UsbMidiInBuf, sizeof(UsbMidiInBuf), UsbMidiOutBuf, sizeof(UsbMidiOutBuf));
#endif
	_USBDDE_SAM5xxx_IOCTL(SAM5XXX_USB_PORT, USB5XXXIOCTL_ACTIVATE, 1);	//enable USB (should be done short before base level loop entry)
}

#endif


extern void bk9532_test(void);
extern void bk9532_callHander(void);
extern void bk9532_TurnLED(WORD value);
//extern void test_Schedule(void);
//extern void csm8s_test(void);

WORD timer_reload_10ms(void)
{
	return (_rdtr0());
}
void delayMsec(WORD ms)
{
	WORD timeout = ms / 10;
	if (timeout <= 0) timeout = 1;
	do {
		_Sys_1msPolling();
		if (timer_reload_10ms())
		{
			timeout--;
		}
	}while(timeout > 0);	
}

void main_loop(void)
{
	
	#if ENABLE_USB
    	DWORD midi_event;
	#endif
	WORD check_func_sync_counter=0;
	WORD check_panel_counter=0;
	WORD check_pair_mic_counter=0;
	WORD pair_mic_power=FALSE;
	WORD check_detect=0;
	// WORD check_PowerON_counter;
    //_Sys_SchedSetResolution(10000);
	_andio(PRM0PORT, ~(1 << 8));
    _andio(SEC0PORT, ~(3 << 12)); 
    _orio(P3DIRPORT, 1 << 5);

    while (1)
    {
		
       // _Sys_SchedTick();	 
	   #ifdef _USE_SERIAL_MIDI
			midi_handle_event();
		#endif					
		#if ENABLE_USB
			_USB_Poll();
			if(_USBMC_PollMidiEvent(&midi_event))	//MIDI message received on USB MIDI?
			{
				dspDesigner_HandleMidiEvent( midi_event );
			}
		#endif  	
		
			// if (timer_reload_10ms())
			// {	
			// 	#ifdef _USE_SERIAL_MIDI
			// 	if(getReceiveCmdPowerValue()==Turn_ON)
			// 	{					
			// 		//TRACE("POWER_ON %d",check_panel_counter);
			// 		 if(!pair_mic_power)
			// 		 {
			// 		 	check_pair_mic_counter++;
			// 		 	if( check_pair_mic_counter>=time_pair_mic)
			// 		 	{
			// 		 		//TRACE("bk9532_mic_skip_pair %d",check_pair_mic_counter);
			// 		 		check_pair_mic_counter=0;
			// 		 		pair_mic_power=TRUE;
			// 		 		bk9532_mic_skip_pair();		
			// 		 	}
			// 		 }else
			// 			FBC_BaseLevels( );
					
			// 		if(!getStatusSyncPanel())
			// 		{
			// 			check_panel_counter++;
			// 			if( check_panel_counter>=time_sync_panel)
			// 			{
			// 				check_panel_counter=0;
			// 				uart_sync_panel();					
			// 			}
			// 		}else
			// 		{
			// 			check_func_sync_counter++;
			// 			if( check_func_sync_counter>=time_sync_func)
			// 			{
			// 				check_func_sync_counter=0;
			// 				update_func_value_to_panel();

			// 				check_detect=check_Mic_Wire_detect();
			// 				set_detect_Mic_Wire(check_detect);
			// 				check_detect=check_guitar_detect();
			// 				set_detect_Guitar(check_detect);
			// 			}					
			// 		}
					
			// 		bk9532_callHander();
			// 		#if USING_PANEL
			// 			ADC_check();									
			// 		#endif

			// 	}else
			// 	{
			// 		//TRACE("POWER_OFF %d",getReceiveCmdPowerValue());
			// 		setStatusSyncPanel(FALSE);
			// 		check_panel_counter=0;
			// 		check_func_sync_counter=0;
			// 		check_pair_mic_counter=0;
			// 		pair_mic_power=FALSE;
			// 		bk9532_mic_reset_pair();
			// 		bk9532_TurnLED(FALSE);					
			// 	}
			// 	#endif
			// }
			uartMC_check_fifo();//check uart RX
			FBC_BaseLevels( );
			bk9532_callHander();
			if (timer_reload_10ms())
			{
				ADC_check();	
				main_power_off_check();	
			}			
    }
}

#define SYS_POWER_BUTTON_ACTIVED 0
void main_power_on_check(void)
{
	WORD power_button_last_state = ~SYS_POWER_BUTTON_ACTIVED;
	DWORD delay = 0;
	// check power on //
	while(1){
		//power_button_last_state = sys_power_button();

		if(power_button_last_state != sys_power_button())
		{
			delay = 0;
		}

		power_button_last_state = sys_power_button();


		if(power_button_last_state == SYS_POWER_BUTTON_ACTIVED && powerState!=Turn_ON)
		{
			delay++;
			if(delay > 300000)
			{
				delay=0;
				powerState=Turn_ON;
				sys_power_latch(1);
				break;
			}
		}
	}
}

void main_power_off_check(void)
{
	static WORD power_button_last_state = ~SYS_POWER_BUTTON_ACTIVED;
	static DWORD delay = 0;
	// check power on //
		//power_button_last_state = sys_power_button();

	if(power_button_last_state != sys_power_button())
	{
		delay = 0;
	}

	power_button_last_state = sys_power_button();
	//TRACE("main_power_off_check ",power_button_last_state);

	if(power_button_last_state == SYS_POWER_BUTTON_ACTIVED && powerState!=Turn_OFF)
	{
		delay++;
		//TRACE("main_power_off_check %d",delay);
		if(delay > 200)
		{
			powerState=Turn_OFF;
			delay=0;
			sys_power_latch(0);
		}
	}
	
}

WORD dspMain, dspASRC;	// DSPs id 


void test_function(void)
{

	WORD dsp1pcs[3];
	_DSPresetAll();					// resets all DSP
#if 0
	// AUDIO PORT //
	//External audio clock 1 (XACLP1) Reg. 0x0F SEC2[9:8]=10b Reg. 0x08 PRM0[0]=0b
	// _andio(PRM0PORT, ~(1 << 0));
    // _orio(SEC2PORT, (1 << 9));
    // _andio(SEC2PORT, ~(1 << 8));

    // _andio(DIGITAL_AUDIO_IN_CONFIG_PORT, 0);
	// _orio(DIGITAL_AUDIO_IN_CONFIG_PORT, (3 << 0));
    // _andio(DIGITAL_AUDIO_CONFIG_PORT, ~(7 << 0));

	// _orio(PRM2PORT, (((1<<9)|(1<<8))|((1<<2)|(1<<1)|(1<<0))));

	//_wrio(CLOCK_AND_RESET_CONTROL0_PORT, 0xC988);
    //_wrio(CLOCK_AND_RESET_CONTROL0_PORT, 0xD12E);

	// /*------------------------------*/
	// /*        ASRC8I2S Module       */
	// /*------------------------------*/
	// // up to 8 channels ASRC on I2S audio inputs
	// WORD _ASRC8I2S_Init( void );
	// void _ASRC8I2S_EnableASRC( WORD DSPid, WORD enable );
	// void _ASRC8I2S_SetInputRate( WORD DSPid, WORD value );
	dspASRC = _ASRC8I2S_Init();
	_ASRC8I2S_EnableASRC(dspASRC, TRUE);
	_DSProutIN( dspASRC, DAAD0L,DAAD0R, -2, -2 );
	_DSProut( dspASRC, IBUS0OUT, IBUS1OUT, -1, -1);
	_StartDSP( dspASRC );
	TRACE("dspASRC", dspASRC);
#endif
 	//_orio(PRM2PORT, (((1<<15)|(1<<8))|((1<<2)|(1<<1)|(1<<0))));
	// mix bt and opt 
	dspMain = _MixPA_Init();

	/* route */
	// Process #1: MixN
	dsp1pcs[1] = _MixPA_MixN_Allocate( dspMain, 4 );
	_MixPA_SetProcIN( dspMain, MIXN_SAMPLE_IN|dsp1pcs[1], PCS_DSP_IN | 0 );
	_MixPA_SetProcOUT( dspMain, MIXN_SAMPLE_OUT|dsp1pcs[1], PCS_NODE | 0 );

	// Process #2: BusSendN
	dsp1pcs[2] = _MixPA_BusSendN_Allocate( dspMain, 4 );
	_MixPA_SetProcIN( dspMain, BUSSENDN_SAMPLE_IN|dsp1pcs[2], PCS_NODE | 0 );
	_MixPA_SetProcOUT( dspMain, BUSSENDN_SAMPLE_OUT|dsp1pcs[2], PCS_DSP_OUT | 0 );


	_DSProutIN( dspMain, DAAD0L, DAAD0R,DAAD1L,DAAD1R );
	//_DSProutIN( dspMain, 0,0,IBUS0IN,IBUS1IN );
	//_DSProutIN( dspMain, IBUS0IN,IBUS1IN, -2, -2 );
	_DSProut( dspMain, DABD0L,DABD0R,DABD1L,DABD1R );
	_StartDSP( dspMain );

	TRACE("dspMain", dspMain);
}

void main(void)
{		
	WORD tmp=0;
	// #ifdef AUTO_POWER_ON
	// sys_timer0_init();
	// delayMsec(3000);//lai
	// #endif
	uart_init();
	sys_timer0_init();
	TRACE("main start %d",tmp);
	
	main_power_on_check();
	sys_io_init();
	pms_init();

	_DSPresetAll();

	dspDesigner_InitAndRoute();
    dspDesigner_InitNrpnFunction();
#if _USE_GLOBAL_PRESET
	dspDesigner_LoadGlobalPreset( _cptr32( globalpreset[0] ) );
#endif

	FBCStatus_Init();
	adc_init();	
	uartMC_init();
#if ENABLE_USB
    InitUSB();	
#endif   	
	//SysVarInit();	
	bk9532_test();
	TRACE("main end %d",tmp);
	main_loop();
			
}


void Send( UCHAR data )
{
    _USBMC_Send( data );
}