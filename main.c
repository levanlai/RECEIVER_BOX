 #include <system.h>
#include <trace.h>
#include <sys5000.h>
#include "sys/sys_io.h"
#include "sys/sys_i2c.h"
#include <libusb.h>
#include "config.h"
#include "dsp/dspDesigner.h"
#include "dsp/midictrl.h"
#include "lcd/uart.h"
#include "user_adc.h"
#if _USE_GLOBAL_PRESET
#include "dsp/GlobalPresets.h"
#endif
#include "libFX5000.h"
#include "utils.h"

WORD powerState=TURN_OFF;
WORD chargeState=CHARGE_UN_PLUS;
WORD iFirstPowerPress=FALSE;
WORD initPowerOn=0;
WORD power_button_last_state = !SYS_POWER_BUTTON_ACTIVED;
DWORD delay = 0;
WORD cnt_SilenceDetect=0;
//power on mic chạy bt trong 3p, sau 3p thì check slepp chu kỳ 5s (5s slepp, 5s scan, nếu kết nối thì ko sleep)-> giảm được 50mA (bt tốn 95mA, sleep còn 45mA)
WORD cnt_checkSleepMic=0;
WORD iCheckSleepMic=MIC_WAIT;
WORD iHasTurnModeSleep=FALSE;

extern MyData_t  myData;
//WORD last_time_PressContinue=0;
//WORD cntPressContinue=0;
#if ENABLE_USB
extern const unsigned short UsbDescriptorInfo[]; //from USB descripter file (generated by UsbDescUI)

// C-preprocessor two-level expansion to build constant
#define _SAM5XXX_PORTNAME(port,val)	SAM5XXX_USB ## port ## _ ## val
#define SAM5XXX_PORTNAME(port,val)	_SAM5XXX_PORTNAME(port, val)
#define	SAM5XXX_USB_PORT	0	//0 or 1 (must be set to 0 on SAM5504/5704)
#define SAM5XXX_USB(val)	SAM5XXX_PORTNAME(SAM5XXX_USB_PORT, val)

WORD UsbMidiInBuf[64], UsbMidiOutBuf[348];	// USB-MIDI queue buffers

// USB Descriptor created with UsbDescUI.exe using Descriptor Export "C-Array" 
// Generated from DDDUsbDescriptor.ucf file (1 MIDI IN & 1 MIDI OUT port, no Audio)
const unsigned short UsbDescriptorInfo[140] = {
	0x0112, 0x0008, 0x0082, 0x0000, 0x0000, 0x0002, 0x0000, 0x0000,	/*     0 */
	0x0004, 0x000D, 0x0011, 0x001E, 0x0031, 0x0308, 0x006E, 0x002F,	/*     8 */
	0x0061, 0x031A, 0x0044, 0x0052, 0x0045, 0x0041, 0x004D, 0x0020,	/*    16 */
	0x0053, 0x002E, 0x0041, 0x002E, 0x0053, 0x002E, 0x0326, 0x0053,	/*    24 */
	0x0041, 0x004D, 0x0035, 0x0030, 0x0030, 0x0030, 0x0020, 0x0045,	/*    32 */
	0x0076, 0x0061, 0x006C, 0x0020, 0x0042, 0x006F, 0x0061, 0x0072,	/*    40 */
	0x0064, 0x0322, 0x0046, 0x0075, 0x006C, 0x006C, 0x0053, 0x0070,	/*    48 */
	0x0065, 0x0065, 0x0064, 0x0020, 0x0043, 0x006F, 0x006E, 0x0066,	/*    56 */
	0x0069, 0x0067, 0x0012, 0x0112, 0x0101, 0x0000, 0x4000, 0x2485,	/*    64 */
	0x433D, 0x0100, 0x0302, 0x0100, 0x0065, 0x0209, 0x0065, 0x0102,	/*    72 */
	0x8004, 0x0932, 0x0004, 0x0000, 0x0101, 0x0000, 0x2409, 0x0001,	/*    80 */
	0x0901, 0x0100, 0x0901, 0x0104, 0x0200, 0x0301, 0x0300, 0x2407,	/*    88 */
	0x0001, 0x4101, 0x0600, 0x0224, 0x0101, 0x0603, 0x0224, 0x0202,	/*    96 */
	0x0903, 0x0324, 0x0301, 0x0201, 0x0301, 0x2409, 0x0203, 0x0104,	/*   104 */
	0x0101, 0x0903, 0x0305, 0x4002, 0x0000, 0x0000, 0x2505, 0x0101,	/*   112 */
	0x0901, 0x8305, 0x4002, 0x0000, 0x0000, 0x2505, 0x0101, 0x0003,	/*   120 */
	0x0502, 0x0006, 0x0042, 0x0000, 0x004C, 0x0000, 0x0000, 0x0000,	/*   128 */
	0x0000, 0x0000, 0x0000, 0x0080
	};

//-------------------------------------------------------------------------
void InitUSB( void )
{
	if( UsbDescriptorInfo[3] != 0 )	//is it a USB descriptor for high speed?
		_USBDDE_SAM5xxx_IOCTL(SAM5XXX_USB_PORT, USB5XXXIOCTL_CONFIGURE, USB5XXX_CONFIGURE_DEVICE|USB5XXX_CONFIGURE_HIGH_SPEED);
	else
		_USBDDE_SAM5xxx_IOCTL(SAM5XXX_USB_PORT, USB5XXXIOCTL_CONFIGURE, USB5XXX_CONFIGURE_DEVICE|USB5XXX_CONFIGURE_FULL_SPEED);
	_USBDDE_SAM5xxx_IOCTL(SAM5XXX_USB_PORT, USB5XXXIOCTL_ACTIVATE, 0);
	_USB_Initialize();
#if _SUPPORT_USB_AUDIO
// initializations for USB Audio+MIDI functions:
	usb_dsp = _DSPalloc(1);	//allocate one DSP for USB Audio function
	_USB_InitRegisterEntry(_USB_PTR(_USBDDE_SAM5xxxAC), usb_dsp);
	_USB_InitStartupEx(_USB_DESC(UsbDescriptorInfo), SAM5XXX_USB(ADDR), 0, SAM5XXX_USB(P24INTBIT));
	_DSProutIN(usb_dsp, DAAD0L,DAAD0R,IBUSEIN,IBUSEIN);	//audio routing for USB to Host (recording)
	_DSProut(usb_dsp, DABD0L,DABD0R,IBUSFOUT,IBUSFOUT);		//audio routing for USB from Host (playback)
#else
// initializations for USB MIDI only functions:
	_USB_InitRegisterEntry(_USB_PTR(_USBDDE_SAM5xxx), 0);
	_USB_InitRegisterEntry(_USB_PTR(_USBDDE_MidiClass), 0);
	_USB_InitStartupEx(_USB_DESC(UsbDescriptorInfo), SAM5XXX_USB(ADDR), SAM5XXX_USB(INTPORT), SAM5XXX_USB(INTBIT) );	// for SAM5XXX on-chip USB device
	_USBMC_InitSetBuffer(UsbMidiInBuf, sizeof(UsbMidiInBuf), UsbMidiOutBuf, sizeof(UsbMidiOutBuf));
#endif
	_USBDDE_SAM5xxx_IOCTL(SAM5XXX_USB_PORT, USB5XXXIOCTL_ACTIVATE, 1);	//enable USB (should be done short before base level loop entry)
}

#endif


extern void bk9532_test(void);
extern void bk9532_callHander(WORD bus);
extern void bk9532_TurnLED(WORD value);
//extern void test_Schedule(void);
//extern void csm8s_test(void);

WORD timer_reload_10ms(void)
{
	return (_rdtr0());
}
void delayMsec(WORD ms)
{
	WORD timeout = ms / 10;
	if (timeout <= 0) timeout = 1;
	do {
		_Sys_1msPolling();
		if (timer_reload_10ms())
		{
			timeout--;
		}
	}while(timeout > 0);	
}

void main_loop(void)
{
	WORD timer_count=0;
	WORD cnt=0;	
	BOOL tmp;
	#if ENABLE_USB
    	DWORD midi_event;
	#endif	
	// WORD check_PowerON_counter;
    //_Sys_SchedSetResolution(10000);
	_andio(PRM0PORT, ~(1 << 8));
    _andio(SEC0PORT, ~(3 << 12)); 
    _orio(P3DIRPORT, 1 << 5);

    while (1)
    {		
       // _Sys_SchedTick();	 
	   #ifdef _USE_SERIAL_MIDI
			midi_handle_event();
		#endif					
		#if ENABLE_USB
			_USB_Poll();
			if(_USBMC_PollMidiEvent(&midi_event))	//MIDI message received on USB MIDI?
			{
				dspDesigner_HandleMidiEvent( midi_event );
			}
		#endif  

		uartMC_check_fifo();//check uart RX
		if (timer_reload_10ms())
		{
			ADC_check();			
			main_power_btn_check();
			//main_power_off_check();
			if(powerState==TURN_ON)
			{
				cnt_checkSleepMic++;
				if(iCheckSleepMic==MIC_WAIT)
				{
					if(cnt_checkSleepMic>14000)//3p
					//if(cnt_checkSleepMic>5000)//1p
					{
						TRACE("MIC_WAIT finish ",cnt_checkSleepMic);
						iCheckSleepMic=MIC_SLEEP;
						iHasTurnModeSleep=FALSE;
						cnt_checkSleepMic=0;
					}
				}else
				{
					if(cnt_checkSleepMic>450)//5s
					//if(cnt_checkSleepMic>2000)//20s
					{
						iCheckSleepMic=(iCheckSleepMic!=MIC_SLEEP) ? MIC_SLEEP : MIC_WAKEUP;
						iHasTurnModeSleep=FALSE;
						cnt_checkSleepMic=0;
						TRACE("MIC_status ",iCheckSleepMic);
					}
				}
				
				// last_time_PressContinue++;
				// if(cntPressContinue>0 && last_time_PressContinue>=5)
				// {
				// 	if(cntPressContinue==1)
				// 		Button_Power_Press(0);
				// 	else
				// 		Button_Power_Press(1);
				// 	cntPressContinue=0;
				// }

				timer_count++;					
				if( timer_count>=100)//2s
				{					
					timer_count=0;
					tmp=check_charge_det();
					//TRACE("charge_det=%d",tmp);
					if(chargeState!=tmp)
					{
						chargeState=tmp;
						uart_send_cmd(CMD_CHARGE_DET, chargeState);
					}
					//tmp=check_plugin_det();
					//TRACE("plugin_det=%d",tmp);
					if(myData.Auto_PowerOff!=AUTO_OFF)
					{
						cnt=_LiveMic_PeakLevel_GetPeak(dsp[DSP4_LIVEMIC],dsp4pcs[9] );
						//TRACE("Peak=%x",cnt);
						if(cnt==0)
						{
							cnt_SilenceDetect++;
							//TRACE("cnt_SilenceDetect=%d",cnt_SilenceDetect);
							//TRACE("auto=%d",myData.Auto_PowerOff);
							if(cnt_SilenceDetect>(getTimeAutoPowerOff()/2))
							{
								cnt_SilenceDetect=0;
								setPowerOff();
							}
						}else
						{
							if(cnt_SilenceDetect!=0)
								cnt_SilenceDetect=0;
						}
					}
				}
			}	
			
			// timer_count++;					
			// if( timer_count>=100)//2s
			// {					
			// 	timer_count=0;
			// 	cnt++;
			// 	uart_send_cmd(0, cnt);			
			// }
		}

		if(powerState==TURN_ON)
		{
			FBC_BaseLevels( );
			if(iCheckSleepMic==MIC_SLEEP)	
			{
				if(!iHasTurnModeSleep)
				{
					// tmp=bk9532_mic_is_connected(I2C_PORT_MIC1);
					// TRACE("MIC_SLEEP check mic1=%d",tmp);
					// tmp=bk9532_mic_is_connected(I2C_PORT_MIC2);
					// TRACE("mic2=%x",tmp);

					iHasTurnModeSleep=TRUE;
					if(!bk9532_mic_is_connected(I2C_PORT_MIC1))
						BK9532_Enter_SoftSleep(I2C_PORT_MIC1);
					
					if(!bk9532_mic_is_connected(I2C_PORT_MIC2))
						BK9532_Enter_SoftSleep(I2C_PORT_MIC2);
				}else
				{
					if(!bk9532_mic_iModeSleep(I2C_PORT_MIC1))
						bk9532_callHander(I2C_PORT_MIC1);				
					
					if(!bk9532_mic_iModeSleep(I2C_PORT_MIC2))
						bk9532_callHander(I2C_PORT_MIC2);
				}	
			}else if(iCheckSleepMic==MIC_WAKEUP)	
			{
				if(!iHasTurnModeSleep)
				{
					// tmp=bk9532_mic_is_connected(I2C_PORT_MIC1);
					// TRACE("MIC_WAKEUP check mic1=%d",tmp);
					// tmp=bk9532_mic_is_connected(I2C_PORT_MIC2);
					// TRACE("mic2=%x",tmp);

					iHasTurnModeSleep=TRUE;
					if(bk9532_mic_iModeSleep(I2C_PORT_MIC1))
						BK9532_Exit_SoftSleep(I2C_PORT_MIC1);
					
					if(bk9532_mic_iModeSleep(I2C_PORT_MIC2))
						BK9532_Exit_SoftSleep(I2C_PORT_MIC2);	
				}else
				{
					bk9532_callHander(I2C_PORT_MIC1);
					bk9532_callHander(I2C_PORT_MIC2);
				}				
			}else
			{	
				bk9532_callHander(I2C_PORT_MIC1);
				bk9532_callHander(I2C_PORT_MIC2);
			}
		}
    }
}

void main_sendCmdPower()
{
	chargeState=check_charge_det();
	uart_send_cmd(CMD_POWER, powerState|(chargeState<<8));
}
void main_sendCmdInfo()
{
	uart_send_cmd(CMD_INFO, FW_VERSION);
}
void setPowerOff()
{
	powerState=TURN_OFF;
	TRACE("POWER_OFF here %d",powerState);
	set_Mute_value(TRUE);
	main_sendCmdPower();
	bk9532_mic_reset_pair();
	cnt_checkSleepMic=0;
	iCheckSleepMic=MIC_WAIT;
	iHasTurnModeSleep=FALSE;
	sys_power_latch(0);
}
void main_power_btn_check(void)
{
	if(sys_power_button()==SYS_POWER_BUTTON_ACTIVED)
	{
		if(powerState==TURN_OFF)
		{
			TRACE("main_power_on_check %d",power_button_last_state);
			if(power_button_last_state!=SYS_POWER_BUTTON_ACTIVED)
			{
				power_button_last_state=SYS_POWER_BUTTON_ACTIVED;				
				//if(initPowerOn==0)
				{
					powerState=TURN_ON;
					initPowerOn=1;
					sys_power_latch(1);
					delayMsec(100);
					SysVarInit();						
					main_sendCmdPower();	
					bk9532_test();
					set_Mute_value(FALSE);
				}				
			}
		}else
		{
			if(power_button_last_state!=SYS_POWER_BUTTON_ACTIVED)
			{				
				power_button_last_state=SYS_POWER_BUTTON_ACTIVED;
				iFirstPowerPress=TRUE;
				delay = 0;
			}else
			{
				if(iFirstPowerPress)
				{
					delay++;
					//TRACE("main_power_off_check %d",delay);
				 	if(delay >= 60)
					{			
						delay=0;
						setPowerOff();	
					}
				}
			}
		}
	}else
	{	
		if(power_button_last_state==SYS_POWER_BUTTON_ACTIVED)
		{			
			TRACE("check here %d",powerState);
			power_button_last_state= !SYS_POWER_BUTTON_ACTIVED;
			if(powerState==TURN_ON)
			{			
				if(initPowerOn==1)
					initPowerOn=2;
				else if(initPowerOn==2)
				{
					//last_time_PressContinue=0;
					//cntPressContinue++;		
					Button_Power_Press(0);
				}
			}
		}
		if(iFirstPowerPress)
			iFirstPowerPress=FALSE;		
	}
}

// void main_power_on_check(void)
// {
// 	// check power on //
// 	while(1){
// 		//power_button_last_state = sys_power_button();

// 		if(power_button_last_state != sys_power_button())
// 		{
// 			delay = 0;
// 		}

// 		power_button_last_state = sys_power_button();


// 		if(power_button_last_state == SYS_POWER_BUTTON_ACTIVED && powerState!=TURN_ON)
// 		{
// 			delay++;
// 			if(delay > 200000)
// 			{
// 				delay=0;
// 				powerState=TURN_ON;
// 				iFirstPowerON=TRUE;
// 				sys_power_latch(1);
// 				break;
// 			}
// 		}
// 	}
// }

// void main_power_off_check(void)
// {	
// 	if(iFirstPowerON)
// 	{
// 		if(sys_power_button()==!SYS_POWER_BUTTON_ACTIVED)
// 		{
// 			iFirstPowerON=FALSE;
// 			power_button_last_state= !SYS_POWER_BUTTON_ACTIVED;
// 		}
// 		return;	
// 	}
// 	if(sys_power_button()==SYS_POWER_BUTTON_ACTIVED)
// 	{
// 		power_button_last_state=SYS_POWER_BUTTON_ACTIVED;
// 		if(powerState!=POWER_OFF)
// 		{
// 			delay++;
// 			//TRACE("main_power_off_check %d",delay);
// 			if(delay > 100)
// 			{
// 				powerState=POWER_OFF;
// 				delay=0;
// 				uart_send_cmd(CMD_POWER, powerState|(chargeState<<8));
// 				sys_power_latch(0);
// 			}
// 		}
				
// 	}else
// 	{
// 		if(power_button_last_state==SYS_POWER_BUTTON_ACTIVED)
// 		{
// 			power_button_last_state= !SYS_POWER_BUTTON_ACTIVED;
// 			delay=0;
// 			if(powerState!=POWER_OFF)
// 			{				
// 				TRACE("Button_Power_Press %d",delay);
// 				Button_Power_Press();
// 			}
// 		}	
// 	}

// 	// if(power_button_last_state != sys_power_button())
// 	// {
// 	// 	delay = 0;
// 	// }

// 	// power_button_last_state = sys_power_button();
// 	// //TRACE("main_power_off_check ",power_button_last_state);

// 	// if
// 	// if(power_button_last_state == SYS_POWER_BUTTON_ACTIVED && powerState!=Turn_OFF)
// 	// {
// 	// 	delay++;
// 	// 	//TRACE("main_power_off_check %d",delay);
// 	// 	if(delay > 200)
// 	// 	{
// 	// 		powerState=Turn_OFF;
// 	// 		delay=0;
// 	// 		sys_power_latch(0);
// 	// 	}
// 	// }
	
// }

// WORD dspMain, dspASRC;	// DSPs id 


// void test_function(void)
// {

// 	WORD dsp1pcs[3];
// 	_DSPresetAll();					// resets all DSP
// #if 0
// 	// AUDIO PORT //
// 	//External audio clock 1 (XACLP1) Reg. 0x0F SEC2[9:8]=10b Reg. 0x08 PRM0[0]=0b
// 	// _andio(PRM0PORT, ~(1 << 0));
//     // _orio(SEC2PORT, (1 << 9));
//     // _andio(SEC2PORT, ~(1 << 8));

//     // _andio(DIGITAL_AUDIO_IN_CONFIG_PORT, 0);
// 	// _orio(DIGITAL_AUDIO_IN_CONFIG_PORT, (3 << 0));
//     // _andio(DIGITAL_AUDIO_CONFIG_PORT, ~(7 << 0));

// 	// _orio(PRM2PORT, (((1<<9)|(1<<8))|((1<<2)|(1<<1)|(1<<0))));

// 	//_wrio(CLOCK_AND_RESET_CONTROL0_PORT, 0xC988);
//     //_wrio(CLOCK_AND_RESET_CONTROL0_PORT, 0xD12E);

// 	// /*------------------------------*/
// 	// /*        ASRC8I2S Module       */
// 	// /*------------------------------*/
// 	// // up to 8 channels ASRC on I2S audio inputs
// 	// WORD _ASRC8I2S_Init( void );
// 	// void _ASRC8I2S_EnableASRC( WORD DSPid, WORD enable );
// 	// void _ASRC8I2S_SetInputRate( WORD DSPid, WORD value );
// 	dspASRC = _ASRC8I2S_Init();
// 	_ASRC8I2S_EnableASRC(dspASRC, TRUE);
// 	_DSProutIN( dspASRC, DAAD0L,DAAD0R, -2, -2 );
// 	_DSProut( dspASRC, IBUS0OUT, IBUS1OUT, -1, -1);
// 	_StartDSP( dspASRC );
// 	TRACE("dspASRC", dspASRC);
// #endif
//  	//_orio(PRM2PORT, (((1<<15)|(1<<8))|((1<<2)|(1<<1)|(1<<0))));
// 	// mix bt and opt 
// 	dspMain = _MixPA_Init();

// 	/* route */
// 	// Process #1: MixN
// 	dsp1pcs[1] = _MixPA_MixN_Allocate( dspMain, 4 );
// 	_MixPA_SetProcIN( dspMain, MIXN_SAMPLE_IN|dsp1pcs[1], PCS_DSP_IN | 0 );
// 	_MixPA_SetProcOUT( dspMain, MIXN_SAMPLE_OUT|dsp1pcs[1], PCS_NODE | 0 );

// 	// Process #2: BusSendN
// 	dsp1pcs[2] = _MixPA_BusSendN_Allocate( dspMain, 4 );
// 	_MixPA_SetProcIN( dspMain, BUSSENDN_SAMPLE_IN|dsp1pcs[2], PCS_NODE | 0 );
// 	_MixPA_SetProcOUT( dspMain, BUSSENDN_SAMPLE_OUT|dsp1pcs[2], PCS_DSP_OUT | 0 );


// 	_DSProutIN( dspMain, DAAD0L, DAAD0R,DAAD1L,DAAD1R );
// 	//_DSProutIN( dspMain, 0,0,IBUS0IN,IBUS1IN );
// 	//_DSProutIN( dspMain, IBUS0IN,IBUS1IN, -2, -2 );
// 	_DSProut( dspMain, DABD0L,DABD0R,DABD1L,DABD1R );
// 	_StartDSP( dspMain );

// 	TRACE("dspMain", dspMain);
// }

void main(void)
{		
	WORD tmp=0;	
	sys_timer0_init();
	uart_init();	
	TRACE("main start %d",tmp);
	sys_io_init();
	uartMC_init();	
	//main_power_on_check();
	
	pms_init();

	_DSPresetAll();

	dspDesigner_InitAndRoute();
    dspDesigner_InitNrpnFunction();
#if _USE_GLOBAL_PRESET
	dspDesigner_LoadGlobalPreset( _cptr32( globalpreset[0] ) );
#endif

	FBCStatus_Init();	
	adc_init();	
#if ENABLE_USB
    InitUSB();	
#endif   	
	TRACE("main end %d",tmp);
	main_loop();
			
}

void Send( UCHAR data )
{
    _USBMC_Send( data );
}